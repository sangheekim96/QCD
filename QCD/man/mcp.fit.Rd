% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcp.fit.R
\name{mcp.fit}
\alias{mcp.fit}
\title{Solve MCP penalized quantile regression by coordinate descent for a single value of lambda}
\usage{
mcp.fit(
  x,
  y,
  tau,
  lambda,
  a,
  weights = NULL,
  warm = NULL,
  thresh = thresh,
  maxit = maxit,
  verbose = FALSE
)
}
\arguments{
\item{x}{n x p design matrix X}

\item{y}{n x 1 vector of response variables Y}

\item{tau}{quantile}

\item{lambda}{single lambda value}

\item{a}{threshold parameter that adjusts constant penalty part (a > 1 for MCP)}

\item{weights}{can input different weight for each p coefficients (default is no weights)}

\item{warm}{whether warm-start will be used (default is NULL). do not use this argument when only running mcp.fit(). it is used when constructing regularization path with qcd.path() later.}

\item{thresh}{threshold of checking whether the coefficients converged}

\item{maxit}{maximum iteration for convergence}

\item{verbose}{whether the iteration number will be printed (verbose = TRUE will print the iteration)}
}
\value{
beta  A n x 1 matrix of coefficients, stored in sparse matrix format

dim  dimension of coefficient matrix

lambda  lambda value used

df  number of nonzero coefficients
}
\description{
Solve MCP penalized quantile regression by coordinate descent for a single value of lambda
}
\examples{
n = 30; p = 30
x = array(rnorm(n*p), c(n,p))
for (j in 1:p){x[,j] = x[,j]/(norm(as.matrix(x[,j]), type="f")/sqrt(n))}
e = rnorm(n)
b = c(1, -1, rep(0, p-2))
y = x \%*\% b + e
qr.mcp = mcp.fit(x = x, y = y, tau = 0.5, lambda = 0.8, a = 2.2,
weights = NULL, warm = NULL, thresh = 1e-06,
maxit = 10000, verbose = TRUE)
}
