% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qcd.fit.R
\name{qcd.fit}
\alias{qcd.fit}
\title{Solve penalized quantile regression by coordinate descent for a single value of lambda with user chosen penalty}
\usage{
qcd.fit(
  x,
  y,
  tau,
  weights,
  lambda,
  a,
  funname = c("LASSO", "SCAD", "MCP"),
  warm = NULL,
  thresh = 1e-06,
  maxit = 1e+05,
  verbose = FALSE
)
}
\arguments{
\item{x}{n x p design matrix X}

\item{y}{n x 1 vector of response variables Y}

\item{tau}{quantile}

\item{weights}{can input different weight for each p coefficients (default is no weights)}

\item{lambda}{single lambda value}

\item{a}{threshold parameter that adjusts constant penalty part for SCAD and MCP (a > 2 for SCAD, a > 1 for MCP)}

\item{funname}{user chosen "LASSO", "SCAD", and "MCP" as the penalty}

\item{warm}{whether warm-start will be used (default is NULL). do not use this argument when only running qcd.fit(). it is used when constructing regularization path with qcd.path() later.}

\item{thresh}{threshold of checking whether the coefficients converged}

\item{maxit}{maximum iteration for convergence (default is 100000)}

\item{verbose}{whether the iteration number will be printed. verbose = TRUE will print the iteration.}
}
\value{
beta  A n x 1 matrix of coefficients, stored in sparse matrix format

dim  dimension of coefficient matrix

lambda  lambda value used

df  number of nonzero coefficients
}
\description{
Solve penalized quantile regression by coordinate descent for a single value of lambda with user chosen penalty
}
\examples{
n = 30; p = 30
x = array(rnorm(n*p), c(n,p))
for (j in 1:p){x[,j] = x[,j]/(norm(as.matrix(x[,j]), type="f")/sqrt(n))}
e = rnorm(n)
b = c(1, -1, rep(0, p-2))
y = x \%*\% b + e

qr.lasso.choice = qcd.fit(x = x, y = y, tau = 0.5, lambda = 0.8,
funname = "LASSO", weights = NULL, warm = NULL,
thresh = 1e-06, maxit = 100, verbose = TRUE)
qr.scad.choice = qcd.fit(x = x, y = y, tau = 0.5, lambda = 0.8, a = 2.2,
                         funname = "SCAD", weights = NULL, warm = NULL,
                         thresh = 1e-06, maxit = 100, verbose = TRUE)
qr.mcp.choice = qcd.fit(x = x, y = y, tau = 0.5, lambda = 0.8, a = 2.2,
                        funname = "MCP", weights = NULL, warm = NULL,
                        thresh = 1e-06, maxit = 100, verbose = TRUE)
}
