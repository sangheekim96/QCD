% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qcd.path.R
\name{qcd.path}
\alias{qcd.path}
\title{solve penalized quantile regression by pathwise coordinate descent for a grid of lambda's with user chosen penalty}
\usage{
qcd.path(
  x,
  y,
  tau,
  funname = c("LASSO", "SCAD", "MCP"),
  a = 2.2,
  weights = NULL,
  lambda = NULL,
  nlambda = 30,
  lambda.min.ratio = ifelse(nobs < nvars, 0.01, 1e-04),
  nudge = FALSE,
  nudgesd = 0.01,
  standardize = FALSE,
  thresh = 1e-06,
  maxit = 1e+05
)
}
\arguments{
\item{x}{\code{n x p} design matrix X.}

\item{y}{\code{n x 1} vector of response variables Y.}

\item{tau}{Quantile value between 0 and 1.}

\item{funname}{User chosen "LASSO", "SCAD", and "MCP" as the penalty.}

\item{a}{Threshold parameter that adjusts constant penalty part for SCAD and MCP. (a > 2 for SCAD, a > 1 for MCP)}

\item{weights}{Can input different weight for each p coefficients. (default is no weights)}

\item{lambda}{Vector of lambda gird.}

\item{nlambda}{Number of lambda grid. automatically calculated if there is no input.}

\item{nudge}{Whether nudge will be added when changing lambda. (default is nudge = FALSE) Recommended to set.seed() before the function if nudge is used.}

\item{nudgesd}{User chosen standard deviation of the random nudge. (default is 0.01)}

\item{standardize}{Whether X will be scaled.}

\item{thresh}{Threshold of checking whether the coefficients converged.}

\item{maxit}{Maximum iteration for convergence.}
}
\value{
\item{beta}{A \code{p x length(lambda)} matrix of coefficients, stored in
sparse matrix format.}

\item{dim}{Dimension of coefficient matrix.}

\item{lambda}{The actual sequence of lambda values used.}

\item{nobs}{Number of observations.}

\item{df}{The number of nonzero coefficients for each value of lambda.}
}
\description{
solve penalized quantile regression by pathwise coordinate descent for a grid of lambda's with user chosen penalty
}
\examples{
## Create sample data set
n <- 30; p <- 30
x <- array(rnorm(n*p), c(n,p))
for (j in 1:p){x[,j] = x[,j]/(norm(as.matrix(x[,j]), type="f")/sqrt(n))}
e <- rnorm(n)
b <- c(1, -1, rep(0, p-2))
y <- x \%*\% b + e

## Create lambda grid
upper <- 2; lower <- -6
lambda <-  2^seq(upper, lower, by = -0.2)

## Use QCD algorithm to solve penalized quantile regression with given lambda grid
qr.lasso.warm = qcd.path(x = x, y = y, tau = 0.5,
funname = "LASSO", weights = NULL, lambda = lambda,
nudge = FALSE, thresh = 1e-06, maxit = 10000)

set.seed(1)
qr.lasso.warm.nudge = qcd.path(x = x, y = y, tau = 0.5,
funname = "LASSO", weights = NULL, lambda = lambda,
nudge = TRUE, nudgesd = 0.2, thresh = 1e-06, maxit = 10000)


}
