---
title: "Calling Fortran from R"
author: "Sumanta Basu"
date: "2024-03-07"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

## Weighted median calculation

```{r}
# Fortran subroutine in file wtdmed.f

# compile the fortran file using R
system("R CMD SHLIB wtdmed.f")

# load the compiled .o (in fact, shared object .so) file
dyn.load("wtdmed.so")

# simulate some data to try the code
set.seed(1)
n = 500
y = round(rnorm(n), 2)
wt = runif(n)

# call the Fortran function to sort data
# and calculate weighted median

out <- .Fortran("wtdmed", 
                v = as.double(y), 
                w = as.double(wt), 
                n = as.integer(length(y)), 
                wmed = as.double(0)
                )

# print the weighted median
print(out$wmed)

# check if correct
# store the sorted data (values and weights) in a data frame
y.wt.df <- data.frame(y = out$v, wt = out$w, 
                      cumw = round(cumsum(out$w)/sum(out$w), 3))
```

An attempt to solve the penalized LAD problem with this weighted median function.

```{r}
# set.seed(1)
dyn.load("wtdmed.so")

n = 500
p = 10

x = array(rnorm(n*p), c(n,p))
e = rnorm(n)
b = c(1, -1, rep(0, p-2))

y = x %*% b + e

lambda.max = norm(x, type = "1")
lambda = 0.5*lambda.max


bhat = rep(0, p)

for (iter in 1:100){
  r = y - x %*% bhat
  
  for (j in 1:p){
    rj = r + x[,j]*bhat[j]

    out <- .Fortran("wtdmed", 
                v = as.double(c(rj/x[,j], 0)), 
                w = as.double(c(abs(x[,j]), lambda)), 
                n = as.integer(n+1), 
                wmed = as.double(0)
                )
    bhat[j] = out$wmed
    r = rj - x[,j]*bhat[j]
  }
}

print(round(bhat, 5))

# [SK] check if correct by using quantreg or some other R packages
library(quantreg)
# [SK]: complete this
```


## Penalized QCD update calculation

```{r}
# Fortran subroutine in file qcdupdate.f

# compile the fortran file using R
system("R CMD SHLIB qcdupdate.f")

# load the compiled .o (in fact, shared object .so) file
dyn.load("qcdupdate.so")

# simulate some data to try the code
# set.seed(10)
n = 15
y = round(rnorm(n), 2)
# x = rep(1,n) # only used for ease of checking correctness
x = round(rnorm(n), 2)

tau = 0.3

# lambda.max = max(abs(t(x) %*% ifelse(y > 0, tau, tau-1)))
lambda.max = max(abs(t(x) %*% ifelse(x > 0, tau, 1-tau)))
print(paste0("lambdamax 1 =", lambda.max))
lambda.max = abs(-sum(abs(x)*ifelse(x > 0, tau, 1-tau)) + sum(abs(x[y < 0])))
print(paste0("lambdamax 2 =", lambda.max))

lambda = 1.05*lambda.max



# call the Fortran function to sort data
# and calculate penalized QCD update

out <- .Fortran("qcdupdate", 
                v = as.double(c(y, 0)), 
                x = as.double(c(x, 0)), 
                n = as.integer(length(y)+1), 
                tau = as.double(tau),
                lambda = as.double(lambda),
                vout = as.double(0)
                )

# print the QCD update
print(out$vout)

# check if correct
# store the sorted data (values and weights) in a data frame
dat <- data.frame(y = y, x = x)
dat <- rbind(dat, c(0, 0))
dat = dat[order(dat$y),]
S = -sum(abs(dat$x)*ifelse(dat$x>0, tau, 1-tau))
dat$wt = cumsum(abs(dat$x))+S
dat$wt = dat$wt + ifelse(dat$y < 0, -lambda, lambda)
idx = min(which(dat$wt > 0))
# print(round(dat[idx+seq(-5,5),], 2))
print(round(dat, 2))
print(out$vout)

```

An attempt to solve the penalized QR problem with this `qcdupdate()` function.

First, simulate data.

```{r}
# set.seed(121)

n = 70
p = 850

tau = 0.3


x = array(rnorm(n*p), c(n,p))
e = rnorm(n)
e = e + quantile(e, probs = tau)
s = 3
b = c(rep(0, p-s), rep(2, s))

y = x %*% b + e

lambda.max = max(diag(t(abs(x)) %*% ifelse(x > 0, tau, 1-tau)))
# the line below won't work, replace x[,j] instead of x, calculate 
# these numbers for j=1,...,p, and then take max over these p numbers
# lambda.max = abs(-sum(abs(x)*ifelse(x > 0, tau, 1-tau)) + sum(abs(x[y < 0])))

lambda = 1.05*lambda.max

b0 = rep(0, p)
```

Now use the `qcdupdate()` function.

```{r}
dyn.load("qcdupdate.so")

ptm <- proc.time()
bhat = b0
for (iter in 1:100){
  r = y - x %*% bhat
  
  for (j in 1:p){
    rj = r + x[,j]*bhat[j]

    out <- .Fortran("qcdupdate", 
                v = as.double(c(rj/x[,j], 0)), 
                x = as.double(c(x[,j], 0)), 
                n = as.integer(n+1), 
                tau = as.double(tau),
                lambda = as.double(lambda),
                vout = as.double(0)
                )
    bhat[j] = out$vout
    r = rj - x[,j]*bhat[j]
  }
  print(round(bhat, 2))
}

print(proc.time()-ptm)

print(round(bhat, 5))
```

Now an attempt to translate the outer loop into Fortran, using the 
function `qcdwarm.f`.

```{r}
# Fortran subroutine in file qcdwarm.f

# compile the fortran file using R
system("R CMD SHLIB qcdwarm.f")
dyn.load("qcdwarm.so")
```

```{r}
bhat = b0

ptm <- proc.time()
out <- .Fortran("qcdwarm", 
                x = matrix(as.double(x), nrow = n, ncol = p),
                y = as.double(y),
                n = as.integer(n),
                p = as.integer(p),
                tau = as.double(tau),
                lambda = as.double(lambda),
                b0 = as.double(b0),
                bhat = as.double(rep(0, p)),
                it = as.integer(1)
                )
print(proc.time()-ptm)

print(round(out$bhat, 2))
print(paste0("No. of iterations = ", out$it))
```


Assess performance with ''nudge'' over a grid of penalty parameters.

```{r}

ptm <- proc.time()

set.seed(1)
lambda.max = max(abs(t(x) %*% ifelse(x > 0, tau, 1-tau)))
lambda.max.norm = log2(lambda.max/(sqrt(n*log(p))))
lambda.grid = sqrt(n*log(p))*2^seq(ceiling(lambda.max.norm)+1, -4, by = -0.25)
rmse.grid = rep(0, length(lambda.grid))

b0 = rep(0, p)

for (l in 1:length(lambda.grid)){
  
  print(paste0("log lambda = ", log2(lambda.grid[l]/(sqrt(n*log(p))))))
  lambda = lambda.grid[l]

  out <- .Fortran("qcdwarm", 
                x = matrix(as.double(x), nrow = n, ncol = p),
                y = as.double(y),
                n = as.integer(n),
                p = as.integer(p),
                tau = as.double(tau),
                lambda = as.double(lambda),
                b0 = as.double(b0),
                bhat = as.double(rep(0, p)),
                it = as.integer(1)
                )
  print(paste0("No. of iterations = ", out$it))
  # print(round(out$bhat, 2))
  b0 = out$bhat+rnorm(p, 0, sd = 0.2)
  
  rmse.grid[l] = sqrt(sum((out$bhat-b)^2)/sum(b^2))
}

plot(log2(lambda.grid/sqrt(log(p)*n)),
     rmse.grid, type = "l", col = "blue",
     lwd = 1.5, ylim = c(0, 2))
abline(h = 1)

print(proc.time()-ptm)
```

Now try an active set selection approach, where we will sequentially expand the active set of variables along the regularization path.

This following code chunk is still work in progress. For some reason, 
it is taking very long to converge to a good active set for many 
values of lambda, resulting in unnecessarily long runtime.
Not sure if it is an issue with incorrect KKT condition, or something
else. Perhaps see what happens for CLASSO and then revisit this issue.

```{r}

check_kkt <- function(xj, v, tau, lambda){
  S = -sum(abs(xj)*ifelse(xj > 0, tau, 1-tau))
  S = S + sum(abs(xj[v < 0]))
  return(ifelse((S - lambda < 0) & (S + lambda >= 0), 0, 1))
}

ptm <- proc.time()

set.seed(1)
lambda.max = max(abs(t(x) %*% ifelse(y > 0, tau, tau-1)))
lambda.max.norm = log2(lambda.max/(sqrt(n*log(p))))
lambda.grid = sqrt(n*log(p))*2^seq(ceiling(lambda.max.norm)+1, -4, by = -0.25)
rmse.grid = rep(0, length(lambda.grid))

b0 = rep(0, p); bhat = b0
bactive = rep(TRUE, p)

for (l in 1:length(lambda.grid)){
  print(paste0("log lambda = ", log2(lambda.grid[l]/(sqrt(n*log(p))))))
  lambda = lambda.grid[l]

  stop_cd = FALSE
  
  while(!stop_cd){

  out <- .Fortran("qcdwarm", 
                x = matrix(as.double(x[,which(bactive)]), 
                           nrow = n, ncol = sum(bactive)),
                y = as.double(y),
                n = as.integer(n),
                p = as.integer(sum(bactive)),
                tau = as.double(tau),
                lambda = as.double(lambda),
                b0 = as.double(b0[which(bactive)]),
                bhat = as.double(rep(0, sum(bactive))),
                it = as.integer(1)
                )
  print(paste0("No. of iterations = ", out$it))
  bactive_old = bactive
  bhat = rep(0, p)
  bhat[bactive] = out$bhat
  bactive = (round(bhat, 3) != 0)
  # print(round(bhat, 2))
  print(sum(bactive))
  
  r = y - x %*% bhat
  
  active_new = rep(FALSE, p)
  for (j in which(!bactive_old)){
    # active_new[j] = check_kkt(x[,j], r/x[,j], tau, lambda.grid[l])
    
    out <- .Fortran("qcdupdate", 
                    v = as.double(c(r/x[,j], 0)), 
                    x = as.double(c(x[,j], 0)), 
                    n = as.integer(n+1), 
                    tau = as.double(tau),
                    lambda = as.double(lambda),
                    vout = as.double(0)
                   )
    active_new[j] = ifelse(out$vout!=0, TRUE, FALSE)
  }
  
  # kkt = t(x) %*% ifelse((y - x %*% bhat) > 0, tau, tau-1)
  # active_new = (abs(kkt) > (lambda.grid[l])) & (!bactive_old)
  if (!any(active_new)){
    stop_cd = TRUE
  } else {
    bactive = bactive_old | active_new
  }
print("active set after KKT check: ")  
    print(sum(bactive))

  
  b0 = rep(0, p)
  b0[bactive] = bhat[bactive]+rnorm(sum(bactive), 0, sd = 0.2)
  }
  
  rmse.grid[l] = sqrt(sum((bhat-b)^2)/sum(b^2))
}

plot(log2(lambda.grid/sqrt(log(p)*n)),
     rmse.grid, type = "l", col = "blue",
     lwd = 1.5, ylim = c(0, 2))
abline(h = 1)

print(proc.time()-ptm)
```






## Soft-thresholding inner product

```{r}
# Fortran subroutine in file lassocd.f

# compile the fortran file using R
system("R CMD SHLIB lassocd.f")

# load the compiled .o (in fact, shared object .so) file
dyn.load("lassocd.so")

# simulate some data to try the code
set.seed(1)
n = 50
rj = round(rnorm(n), 2)
xj = round(rnorm(n), 2)
lambda = 0.01

# call the Fortran function to compute 
# inner product, and then soft-threshold

out <- .Fortran("lassocd", 
                rj = as.double(rj), 
                xj = as.double(xj), 
                n = as.integer(n),
                lambda = as.double(lambda),
                sxr = as.double(0)
                )

# print S_lambda(<Xj,r>/n)
print(out$sxr)

# check if correct
tmp <- mean(rj*xj)
print(max(abs(tmp)-lambda, 0)*sign(tmp))

```

An attempt to solve the LASSO problem with this soft-thresholded inner product function.

```{r}
set.seed(1)
dyn.load("lassocd.so")

n = 100
p = 10

x = array(rnorm(n*p), c(n,p))
for (j in 1:p){x[,j] = x[,j]/(norm(as.matrix(x[,j]), type="f")/sqrt(n))}

e = rnorm(n)
b = c(1, -1, rep(0, p-2))

y = x %*% b + e

lambda = 0.1

bhat = rep(0, p)

for (iter in 1:10000){
  r = y - x %*% bhat
  
  for (j in 1:p){
    rj = r + x[,j]*bhat[j]

out <- .Fortran("lassocd", 
                rj = as.double(rj), 
                xj = as.double(x[,j]), 
                n = as.integer(n),
                lambda = as.double(lambda),
                sxr = as.double(0)
                )
    bhat[j] = out$sxr
    r = rj - x[,j]*bhat[j]
  }
}

print(round(bhat, 2))

# check if correct
library(glmnet)
round(glmnet(x, y, lambda = lambda, intercept = FALSE)$beta, 2)

```

